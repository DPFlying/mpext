const t=wx,e={page:["onLoad","onUnload"],component:["attached","detached"]},n=Array.isArray,o=t=>"function"==typeof t,c=Object.prototype.toString,s=t=>"[object Object]"===c.call(t),r=t=>c.call(t),a=Object.keys,i=t=>a(t).length<1,l=t=>{throw new Error(t)};function f(e){s(e)||l("provider必须是一个Object");const{store:n,namespace:o="",manual:c=!1}=e;n||l("store必须为Redux的Store实例对象"),t.$$provider={store:n,namespace:o,manual:c}}function u(){return t.$$provider||l("请先设置provider"),t.$$provider}let h=[];function p(t){const e=u().store.getState(),n={};for(let o=0,c=t.length;o<c;o++){const c=t[o];c in e&&(n[c]=e[c])}return i(n)?null:n}function g(t,e){const n=u().store.getState();e&&(h=[],function(t){const e=a(t);for(let n=0,o=e.length;n<o;n++){const o=e[n],c=Object.getOwnPropertyDescriptor(t,o);if(c&&!1===c.configurable)throw new Error("Function 类型的 mapState 需要使用 defineProperty 进行依赖收集，请勿将 configurable 属性定义为 false");const s=c&&c.get;if(s&&s.__ob__)continue;const r=c&&c.set;let a=t[o];const i=()=>(h.indexOf(o)<0&&h.push(o),s?s.call(t):a);i.__ob__=!0;const l=e=>{s&&!r||(r?r.call(t,e):a=e)};Object.defineProperty(t,o,{configurable:!0,enumerable:!0,get:i,set:l})}}(n));const o=t(n);if(!s(o))throw new Error("mapState 函数必须返回一个对象");return[i(o)?null:o,e?[...h]:null]}function b(t,e=!1){return n(t)?[p(t),e?[...t]:null]:o(t)?g(t,e):[null,null]}function d(t,e){s(t)?function(t,e){const{dispatch:n}=u().store;for(const c in t){const s=t[c];o(s)&&(e[c]=(...t)=>n(s.apply(null,t)))}}(t,e):o(t)&&function(t,e){const n=t(u().store.dispatch);if(!s(n))throw new Error("mapDispatch 函数必须返回一个对象");Object.assign(e,n)}(t,e)}function j(t,e,n,o){const c=a(t),s=a(e),i=c.length,l=s.length;if(!(i<1&&l<1))if(i<1||l<1||i<l)n[o]=t;else{for(let e=0;e<l;e++){const r=s[e];if(c.indexOf(r)<0)return void(n[o]=t)}for(let a=0;a<i;a++){const i=c[a],l=t[i],f=`${o}.${i}`;if(s.indexOf(i)<0){n[f]=l;continue}const u=e[i];if(l!==u){const t=r(l);t!==r(u)?n[f]=l:"[object Object]"===t?j(l,u,n,f):"[object Array]"===t?m(l,u,n,f):n[f]=l}}}}function m(t,e,n,o){const c=t.length,s=e.length;if(!(c<1&&s<1))if(c<1||s<1||c<s)n[o]=t;else for(let a=0;a<c;a++){const c=t[a],i=`${o}[${a}]`;if(a>=s){n[i]=c;continue}const l=e[a];if(c!==l){const t=r(c);t!==r(l)?n[i]=c:"[object Object]"===t?j(c,l,n,i):"[object Array]"===t?m(c,l,n,i):n[i]=c}}}function O(t,e,n=""){const o=a(t),c=a(e),s=o.length,i=c.length;if(s<1&&i<1)return{};if(s<1||i<1)return n?{[n]:t}:t;const l={};for(let a=0;a<s;a++){const s=o[a],i=t[s],f=n?`${n}.${s}`:s;if(c.indexOf(s)<0){l[f]=i;continue}const u=e[s];if(i!==u){const t=r(i);t!==r(u)?l[f]=i:"[object Object]"===t?j(i,u,l,f):"[object Array]"===t?m(i,u,l,f):l[f]=i}}return l}var y=new class{constructor(){this.queue=[]}push(t,e,n){const c=this.queue;let s=null;for(let e=0,n=c.length;e<n;e++)if(c[e].thisArg===t){s=c[e];break}s||(s={thisArg:t,data:{},callbacks:[]},c.push(s)),Object.assign(s.data,e),o(n)&&s.callbacks.push(n),Promise.resolve().then(this.exec.bind(this))}exec(){if(this.queue.length<1)return;const t=this.queue;this.queue=[];const{namespace:e}=u();for(let n=0,o=t.length;n<o;n++){const o=t[n],{thisArg:c,data:s}=o,r=O(s,e?c.data[e]:c.data,e);i(r)||(o.diffData=r)}let n;for(;n=t.shift();){const{thisArg:t,diffData:e,callbacks:o}=n;let c;o.length>0&&(c=()=>{let t;for(;t=o.shift();)t()}),e?t.setData(e,c):c&&c()}}};let w=0,$=0;function x({type:t="page",mapState:o,mapDispatch:c,manual:s}={}){const{namespace:r,manual:a}=u();if(t&&"page"!==t&&"component"!==t)throw new Error("type 属性只能是 page 或 component");return"boolean"!=typeof s&&(s=a),function(a){const l="page"===t;if(a.$type=t,o){const[c,s]=b(o,!0);if(c){const[l,f]=e[t],h=a[l],p=a[f];let g=null;a.data=Object.assign(a.data||{},r?{[r]:c}:c),a[l]=function(...t){const e=O(b(o,!1)[0],r?this.data[r]:this.data,r);i(e)||this.setData(e),g=function(t,e,o){w+=1;const{store:c}=u();let s=c.getState();const r=c.subscribe(()=>{$+=1;const r=c.getState();let a=null;if(n(e))for(let t=0,n=e.length;t<n;t++){const n=e[t];r[n]!==s[n]&&(a||(a={}),a[n]=r[n])}else for(let t=0,n=o.length;t<n;t++){const n=o[t];if(r[n]!==s[n]){a=e(r);break}}a&&y.push(t,a),s=r,$===w&&($=0,y.exec())});return()=>{w-=1,r()}}(this,o,s),h&&h.apply(this,t)},a[f]=function(){p&&p.call(this),g&&(g(),g=null)}}}if(c){const t=l?a:a.methods=a.methods||{};d(c,t)}return s?a:l?Page(a):Component(a)}}const S=(t={})=>x(Object.assign(Object.assign({},t),{type:"page"})),A=(t={})=>x(Object.assign(Object.assign({},t),{type:"component"})),v=()=>u().store,_=()=>u().store.getState(),D=()=>{const{store:t}=u();return t.dispatch.bind(t)};export{A as $component,S as $page,x as connect,f as setProvider,D as useDispatch,_ as useState,v as useStore};
