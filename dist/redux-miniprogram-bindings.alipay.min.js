const t=my,e={page:["onLoad","onUnload"],component:["didMount","didUnmount"]},n=Array.isArray,o=t=>"function"==typeof t,c=Object.prototype.toString,s=t=>"[object Object]"===c.call(t),r=t=>c.call(t),i=Object.keys,a=t=>i(t).length<1,l=t=>{throw new Error(t)};function u(e){s(e)||l("provider必须是一个Object");const{store:n,namespace:o="",manual:c=!1}=e;n||l("store必须为Redux的Store实例对象"),t.$$provider={store:n,namespace:o,manual:c}}function f(){return t.$$provider||l("请先设置provider"),t.$$provider}let p=[];function h(t){const e=f().store.getState(),n={};for(let o=0,c=t.length;o<c;o++){const c=t[o];c in e&&(n[c]=e[c])}return a(n)?null:n}function g(t,e){const n=f().store.getState();e&&(p=[],function(t){const e=i(t);for(let n=0,o=e.length;n<o;n++){const o=e[n],c=Object.getOwnPropertyDescriptor(t,o);if(c&&!1===c.configurable)throw new Error("Function 类型的 mapState 需要使用 defineProperty 进行依赖收集，请勿将 configurable 属性定义为 false");const s=c&&c.get;if(s&&s.__ob__)continue;const r=c&&c.set;let i=t[o];const a=()=>(p.indexOf(o)<0&&p.push(o),s?s.call(t):i);a.__ob__=!0;const l=e=>{s&&!r||(r?r.call(t,e):i=e)};Object.defineProperty(t,o,{configurable:!0,enumerable:!0,get:a,set:l})}}(n));const o=t(n);if(!s(o))throw new Error("mapState 函数必须返回一个对象");return[a(o)?null:o,e?[...p]:null]}function b(t,e=!1){return n(t)?[h(t),e?[...t]:null]:o(t)?g(t,e):[null,null]}function d(t,e){s(t)?function(t,e){const{dispatch:n}=f().store;for(const c in t){const s=t[c];o(s)&&(e[c]=(...t)=>n(s.apply(null,t)))}}(t,e):o(t)&&function(t,e){const n=t(f().store.dispatch);if(!s(n))throw new Error("mapDispatch 函数必须返回一个对象");Object.assign(e,n)}(t,e)}function m(t,e,n,o){const c=i(t),s=i(e),a=c.length,l=s.length;if(!(a<1&&l<1))if(a<1||l<1||a<l)n[o]=t;else{for(let e=0;e<l;e++){const r=s[e];if(c.indexOf(r)<0)return void(n[o]=t)}for(let i=0;i<a;i++){const a=c[i],l=t[a],u=`${o}.${a}`;if(s.indexOf(a)<0){n[u]=l;continue}const f=e[a];if(l!==f){const t=r(l);t!==r(f)?n[u]=l:"[object Object]"===t?m(l,f,n,u):"[object Array]"===t?j(l,f,n,u):n[u]=l}}}}function j(t,e,n,o){const c=t.length,s=e.length;if(!(c<1&&s<1))if(c<1||s<1||c<s)n[o]=t;else for(let i=0;i<c;i++){const c=t[i],a=`${o}[${i}]`;if(i>=s){n[a]=c;continue}const l=e[i];if(c!==l){const t=r(c);t!==r(l)?n[a]=c:"[object Object]"===t?m(c,l,n,a):"[object Array]"===t?j(c,l,n,a):n[a]=c}}}function O(t,e,n=""){const o=i(t),c=i(e),s=o.length,a=c.length;if(s<1&&a<1)return{};if(s<1||a<1)return n?{[n]:t}:t;const l={};for(let i=0;i<s;i++){const s=o[i],a=t[s],u=n?`${n}.${s}`:s;if(c.indexOf(s)<0){l[u]=a;continue}const f=e[s];if(a!==f){const t=r(a);t!==r(f)?l[u]=a:"[object Object]"===t?m(a,f,l,u):"[object Array]"===t?j(a,f,l,u):l[u]=a}}return l}var y=new class{constructor(){this.queue=[]}push(t,e,n){const c=this.queue;let s=null;for(let e=0,n=c.length;e<n;e++)if(c[e].thisArg===t){s=c[e];break}s||(s={thisArg:t,data:{},callbacks:[]},c.push(s)),Object.assign(s.data,e),o(n)&&s.callbacks.push(n),Promise.resolve().then(this.exec.bind(this))}exec(){if(this.queue.length<1)return;const t=this.queue;this.queue=[];const{namespace:e}=f();for(let n=0,o=t.length;n<o;n++){const o=t[n],{thisArg:c,data:s}=o,r=O(s,e?c.data[e]:c.data,e);a(r)||(o.diffData=r)}let n;for(;n=t.shift();){const{thisArg:t,diffData:e,callbacks:o}=n;let c;o.length>0&&(c=()=>{let t;for(;t=o.shift();)t()}),e?t.setData(e,c):c&&c()}}};let $=0,w=0;function S({type:t="page",mapState:o,mapDispatch:c,manual:s}={}){const{namespace:r,manual:i}=f();if(t&&"page"!==t&&"component"!==t)throw new Error("type 属性只能是 page 或 component");return"boolean"!=typeof s&&(s=i),function(i){const l="page"===t;if(i.$type=t,o){const[c,s]=b(o,!0);if(c){const[l,u]=e[t],p=i[l],h=i[u];let g=null;i.data=Object.assign(i.data||{},r?{[r]:c}:c),i[l]=function(...t){const e=O(b(o,!1)[0],r?this.data[r]:this.data,r);a(e)||this.setData(e),g=function(t,e,o){$+=1;const{store:c}=f();let s=c.getState();const r=c.subscribe(()=>{w+=1;const r=c.getState();let i=null;if(n(e))for(let t=0,n=e.length;t<n;t++){const n=e[t];r[n]!==s[n]&&(i||(i={}),i[n]=r[n])}else for(let t=0,n=o.length;t<n;t++){const n=o[t];if(r[n]!==s[n]){i=e(r);break}}i&&y.push(t,i),s=r,w===$&&(w=0,y.exec())});return()=>{$-=1,r()}}(this,o,s),p&&p.apply(this,t)},i[u]=function(){h&&h.call(this),g&&(g(),g=null)}}}if(c){const t=l?i:i.methods=i.methods||{};d(c,t)}return s?i:l?Page(i):Component(i)}}const x=(t={})=>S(Object.assign(Object.assign({},t),{type:"page"})),A=(t={})=>S(Object.assign(Object.assign({},t),{type:"component"})),v=()=>f().store,_=()=>f().store.getState(),D=()=>{const{store:t}=f();return t.dispatch.bind(t)};export{A as $component,x as $page,S as connect,u as setProvider,D as useDispatch,_ as useState,v as useStore};
