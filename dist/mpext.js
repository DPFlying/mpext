let t=null;function n(){return t}function e(n){t=n}const o=t=>Object.prototype.toString.call(t),c=t=>"[object Object]"===o(t),s=(t,n)=>Object.prototype.hasOwnProperty.call(t,n),a=t=>"function"==typeof t,r=t=>Object.keys(t).length<1;function i(t){if(!c(t))throw new TypeError(`${t}不是一个对象`);const e=n();if(!e)return{};const{storeName:o="$store",mapState:r,mapDispatch:i}=t;let l=null;if(Array.isArray(r)&&r.length>0){const t=e.getState();(l=r.filter(n=>s(t,n))).length<1&&(l=null)}const u=!!l;let f=!1,h={};return c(i)&&Object.keys(i).forEach(t=>{const n=i[t];a(n)&&(f=!0,h[t]=n)}),f||(h=null),{storeName:o,hasMapState:u,ownStateKeys:l,hasMapDispatch:f,ownActionCreators:h}}function l(t,e){const o=n().getState();this.setData({[e]:t.reduce((t,n)=>(t[n]=o[n],t),{})})}const u="[object Object]",f="[object Array]";function h(t,n,e=""){const c=Object.keys(t),a=Object.keys(n),r=c.length,i=a.length;if(!r&&!i)return{};if(!r||!i)return t;const l={};for(let a=0;a<r;a++){const r=c[a],i=t[r],h=e+r;if(!s(n,r)){l[h]=i;continue}const d=n[r];if(i!==d){const t=o(i);t!==o(d)?l[h]=i:t===u?p(i,d,l,h):t===f?y(i,d,l,h):l[h]=i}}return l}function p(t,n,e,c){const a=Object.keys(t),r=Object.keys(n),i=a.length,l=r.length;if(i||l)if(!i||!l||i<l)e[c]=t;else{for(let n=0;n<l;n++){const o=r[n];if(!s(t,o))return void(e[c]=t)}for(let r=0;r<i;r++){const i=a[r],l=t[i],h=`${c}.${i}`;if(!s(n,i)){e[h]=l;continue}const d=n[i];if(l!==d){const t=o(l);t!==o(d)?e[h]=l:t===u?p(l,d,e,h):t===f?y(l,d,e,h):e[h]=l}}}}function y(t,n,e,c){const s=t.length,a=n.length;if(s||a)if(!s||!a||s<a)e[c]=t;else for(let r=0;r<s;r++){const s=t[r],i=`${c}[${r}]`;if(r>=a){e[i]=s;continue}const l=n[r];if(s!==l){const t=o(s);t!==o(l)?e[i]=s:t===u?p(s,l,e,i):t===f?y(s,l,e,i):e[i]=s}}}function d(t,e){const o=n();let c=o.getState();return o.subscribe(()=>{let n=!1;const s=o.getState(),a=t.reduce((t,e)=>(s[e]!==c[e]&&(n=!0,t[e]=s[e]),t),{});if(n){const t=h(a,this.data[e],`${e}.`);r(t)||this.setData(t)}c=s})}function b(t){const{dispatch:e}=n();return Object.keys(t).reduce((n,o)=>{const c=t[o];return n[o]=(...t)=>e(c(...t)),n},{})}function g(t,n){if(!c(t))throw new TypeError(`${t}不是一个对象`);if(r(t)&&a(n))return void n();const e=h(t,this.data);r(e)?a(n)&&n():this.setData(e,n)}let j={};function O(){return j}function w(t){if(!c(t))throw new TypeError(`${t}不是一个对象`);if(!Object.keys(t).every(n=>a(t[n])))throw new TypeError("目前只支持混入方法");j=t}function m(t={}){const{storeName:e,hasMapState:o,ownStateKeys:c,hasMapDispatch:s,ownActionCreators:u}=i(t);return function(t){const{onLoad:i,onUnload:f}=t,h=!!n();let p=null;const y=O(),j=!r(y);return t.onLoad=function(t){h&&o&&(l.call(this,c,e),p=d.call(this,c,e)),i&&i.call(this,t)},t.onUnload=function(){f&&f.call(this),a(p)&&(p(),p=null)},h&&s&&Object.assign(t,b(u)),t.$setData=function(...t){g.apply(this,t)},j&&Object.assign(t,y),Page(t)}}function S(t={}){const{storeName:e,hasMapState:o,ownStateKeys:c,hasMapDispatch:s,ownActionCreators:u}=i(t);return function(t){const{attached:i,detached:f}=t,h=!!n();let p=null;const y=O(),j=!r(y);return t.attached=function(){h&&o&&(l.call(this,c,e),p=d.call(this,c,e)),i&&i.call(this)},t.detached=function(){f&&f.call(this),a(p)&&(p(),p=null)},t.methods||(t.methods={}),h&&s&&Object.assign(t.methods,b(u)),t.methods.$setData=function(...t){g.apply(this,t)},j&&Object.assign(t.methods,y),Component(t)}}export{S as $component,m as $page,n as getStore,w as setMixin,e as setStore};
