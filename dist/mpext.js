const t=Object.prototype.toString,n=n=>t.call(n),e=t=>"[object Object]"===n(t),o=Object.prototype.hasOwnProperty,s=(t,n)=>o.call(t,n),c=t=>"function"==typeof t,a=t=>Object.keys(t).length<1,r="[object Object]",i="[object Array]";function l(t,e,o=""){const c=Object.keys(t),a=Object.keys(e),l=c.length,u=a.length;if(!l&&!u)return{};if(!l||!u)return t;const p={};for(let a=0;a<l;a++){const l=c[a],u=t[l],y=o+l;if(!s(e,l)){p[y]=u;continue}const g=e[l];if(u!==g){const t=n(u);t!==n(g)?p[y]=u:t===r?f(u,g,p,y):t===i?h(u,g,p,y):p[y]=u}}return p}function f(t,e,o,c){const a=Object.keys(t),l=Object.keys(e),u=a.length,p=l.length;if(u||p)if(!u||!p||u<p)o[c]=t;else{for(let n=0;n<p;n++){const e=l[n];if(!s(t,e))return void(o[c]=t)}for(let l=0;l<u;l++){const u=a[l],p=t[u],y=`${c}.${u}`;if(!s(e,u)){o[y]=p;continue}const g=e[u];if(p!==g){const t=n(p);t!==n(g)?o[y]=p:t===r?f(p,g,o,y):t===i?h(p,g,o,y):o[y]=p}}}}function h(t,e,o,s){const c=t.length,a=e.length;if(c||a)if(!c||!a||c<a)o[s]=t;else for(let l=0;l<c;l++){const c=t[l],u=`${s}[${l}]`;if(l>=a){o[u]=c;continue}const p=e[l];if(c!==p){const t=n(c);t!==n(p)?o[u]=c:t===r?f(c,p,o,u):t===i?h(c,p,o,u):o[u]=c}}}let u=null;function p(){return u}function y(t){u=t}function g(t){const n={storeName:"$store",hasMapState:!1,ownStateKeys:null,hasMapDispatch:!1,ownActionCreators:null};if(!u)return n;const{storeName:o,mapState:a,mapDispatch:r}=t;if(o&&(n.storeName=o),Array.isArray(a)&&a.length>0){const t=u.getState(),e=[];let o=a.length;for(;o--;)s(t,a[o])&&e.unshift(a[o]);e.length>0&&(n.hasMapState=!0,n.ownStateKeys=e)}if(e(r)){let t=!1;const e={},{dispatch:o}=u,s=Object.keys(r);let a=s.length;for(;a--;){const n=s[a],i=r[n];c(i)&&(t=!0,e[n]=(...t)=>o(i(...t)))}t&&(n.hasMapDispatch=!0,n.ownActionCreators=e)}return n}function d(t,n){const e=u.getState(),o={};let s=t.length;for(;s--;){const n=t[s];o[n]=e[n]}this.setData({[n]:o})}function w(t,n){let e=u.getState();return u.subscribe(()=>{let o=!1;const s={},c=u.getState();let r=t.length;for(;r--;){const n=t[r];c[n]!==e[n]&&(o=!0,s[n]=c[n])}if(o){const t=l(s,this.data[n],`${n}.`);a(t)||this.setData(t)}e=c})}function b(t,n){const e=Object.keys(n);let o=e.length;for(;o--;){const s=e[o];t[s]=n[s]}}function j(t,n){if(!e(t))throw new TypeError("setData第一个参数必须是一个对象");if(a(t))return void(c(n)&&n());const o=l(t,this.data);a(o)?c(n)&&n():this.setData(o,n)}let S=null,m=null;function O(t){if(!e(t))throw new TypeError("混入参数必须是一个对象");const n=Object.keys(t);let o=n.length;if(!(o<1)){for(;o--;)if(!c(t[n[o]]))throw new TypeError("目前只支持混入方法");S=t,m=n}}function D(t){if(!S)return;let n=m.length;for(;n--;){const e=m[n];s(t,e)||(t[e]=S[e])}}function k(t={}){if(!e(t))throw new TypeError("配置参数必须是一个对象");const{storeName:n,hasMapState:o,ownStateKeys:s,hasMapDispatch:a,ownActionCreators:r}=g(t);return function(t){const{onLoad:e,onUnload:i}=t,l=!!p();let f=null;return t.onLoad=function(t){l&&o&&(d.call(this,s,n),f=w.call(this,s,n)),e&&e.call(this,t)},t.onUnload=function(){i&&i.call(this),c(f)&&(f(),f=null)},D(t),l&&a&&b(t,r),t.$setData=function(...t){j.apply(this,t)},Page(t)}}function M(t={}){if(!e(t))throw new TypeError("配置参数必须是一个对象");const{storeName:n,hasMapState:o,ownStateKeys:s,hasMapDispatch:a,ownActionCreators:r}=g(t);return function(t){const{attached:e,detached:i}=t,l=!!p();let f=null;return t.attached=function(){l&&o&&(d.call(this,s,n),f=w.call(this,s,n)),e&&e.call(this)},t.detached=function(){i&&i.call(this),c(f)&&(f(),f=null)},t.methods||(t.methods={}),D(t.methods),l&&a&&b(t.methods,r),t.methods.$setData=function(...t){j.apply(this,t)},Component(t)}}export{M as $component,k as $page,p as getStore,O as setMixin,y as setStore};
