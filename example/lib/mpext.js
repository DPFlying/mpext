const t=Object.prototype.toString,n=n=>t.call(n),e=t=>"[object Object]"===n(t),o=Object.prototype.hasOwnProperty,s=(t,n)=>o.call(t,n),c=t=>"function"==typeof t,a=t=>Object.keys(t).length<1,i="[object Object]",l="[object Array]";function r(t,e,o=""){const c=Object.keys(t),a=Object.keys(e),r=c.length,u=a.length;if(!r&&!u)return{};if(!r||!u)return t;const p={};for(let a=0;a<r;a++){const r=c[a],u=t[r],g=o+r;if(!s(e,r)){p[g]=u;continue}const d=e[r];if(u!==d){const t=n(u);t!==n(d)?p[g]=u:t===i?h(u,d,p,g):t===l?f(u,d,p,g):p[g]=u}}return p}function h(t,e,o,c){const a=Object.keys(t),r=Object.keys(e),u=a.length,p=r.length;if(u||p)if(!u||!p||u<p)o[c]=t;else{for(let n=0;n<p;n++){const e=r[n];if(!s(t,e))return void(o[c]=t)}for(let r=0;r<u;r++){const u=a[r],p=t[u],g=`${c}.${u}`;if(!s(e,u)){o[g]=p;continue}const d=e[u];if(p!==d){const t=n(p);t!==n(d)?o[g]=p:t===i?h(p,d,o,g):t===l?f(p,d,o,g):o[g]=p}}}}function f(t,e,o,s){const c=t.length,a=e.length;if(c||a)if(!c||!a||c<a)o[s]=t;else for(let r=0;r<c;r++){const c=t[r],u=`${s}[${r}]`;if(r>=a){o[u]=c;continue}const p=e[r];if(c!==p){const t=n(c);t!==n(p)?o[u]=c:t===i?h(c,p,o,u):t===l?f(c,p,o,u):o[u]=c}}}class u{constructor(){this.list=[]}push(t,n,e){const o=this.list,s=this.exec.bind(this);let a=o.length;for(;a--;){const i=o[a];if(i.thisArg===t)return Object.assign(i.data,n),c(e)&&i.callback.push(e),void setTimeout(s,0)}const i={thisArg:t,data:n,callback:[]};c(e)&&i.callback.push(e),o.push(i),setTimeout(s,0)}exec(){const t=this.list;let n=t.length;if(0!==n)for(;n--;){const{thisArg:e,data:o,callback:s}=t[n];e.setData(o,()=>{s.forEach(t=>t())}),t.splice(n,1)}}}let p=null;const g=new u;function d(){return p}function y(t){p=t}function b(t){const n={storeName:"$store",hasMapState:!1,ownStateKeys:null,hasMapDispatch:!1,ownActionCreators:null};if(!p)return n;const{storeName:o,mapState:a,mapDispatch:i}=t;if(o&&(n.storeName=o),Array.isArray(a)&&a.length>0){const t=p.getState(),e=[];let o=a.length;for(;o--;)s(t,a[o])&&e.unshift(a[o]);e.length>0&&(n.hasMapState=!0,n.ownStateKeys=e)}if(e(i)){let t=!1;const e={},{dispatch:o}=p,s=Object.keys(i);let a=s.length;for(;a--;){const n=s[a],l=i[n];c(l)&&(t=!0,e[n]=(...t)=>o(l(...t)))}t&&(n.hasMapDispatch=!0,n.ownActionCreators=e)}return n}function w(t,n){const e=p.getState(),o={};let s=t.length;for(;s--;){const n=t[s];o[n]=e[n]}this.setData({[n]:o})}function j(t,n){let e=p.getState();return p.subscribe(()=>{let o=!1;const s={},c=p.getState();let i=t.length;for(;i--;){const n=t[i];c[n]!==e[n]&&(o=!0,s[n]=c[n])}if(o){const t=r(s,this.data[n],`${n}.`);a(t)||g.push(this,t)}e=c})}function m(t,n){const e=Object.keys(n);let o=e.length;for(;o--;){const s=e[o];t[s]=n[s]}}const O=new u;function S(t,n){if(!e(t))throw new TypeError("setData第一个参数必须是一个对象");if(a(t))return void(c(n)&&n());const o=r(t,this.data);a(o)?c(n)&&n():O.push(this,o,n)}let k=null,A=null;function D(t){if(!e(t))throw new TypeError("混入参数必须是一个对象");const n=Object.keys(t);let o=n.length;if(!(o<1)){for(;o--;)if(!c(t[n[o]]))throw new TypeError("目前只支持混入方法");k=t,A=n}}function M(t){if(!k)return;let n=A.length;for(;n--;){const e=A[n];s(t,e)||(t[e]=k[e])}}function $(t={}){if(!e(t))throw new TypeError("配置参数必须是一个对象");const{storeName:n,hasMapState:o,ownStateKeys:s,hasMapDispatch:a,ownActionCreators:i}=b(t);return function(t){const{onLoad:e,onUnload:l}=t,r=!!d();let h=null;return t.onLoad=function(t){r&&o&&(w.call(this,s,n),h=j.call(this,s,n)),e&&e.call(this,t)},t.onUnload=function(){l&&l.call(this),c(h)&&(h(),h=null)},M(t),r&&a&&m(t,i),t.$setData=function(...t){S.apply(this,t)},Page(t)}}const T={load:"attached",unload:"detached"};function E(t={}){if(!e(t))throw new TypeError("配置参数必须是一个对象");const{storeName:n,hasMapState:o,ownStateKeys:s,hasMapDispatch:a,ownActionCreators:i}=b(t);return function(t){const{load:e,unload:l}=T,r=t[e],h=t[l],f=!!d();let u=null;return t[e]=function(){f&&o&&(w.call(this,s,n),u=j.call(this,s,n)),r&&r.call(this)},t[l]=function(){h&&h.call(this),c(u)&&(u(),u=null)},t.methods||(t.methods={}),M(t.methods),f&&a&&m(t.methods,i),t.methods.$setData=function(...t){S.apply(this,t)},Component(t)}}export{E as $component,$ as $page,d as getStore,D as setMixin,y as setStore};
